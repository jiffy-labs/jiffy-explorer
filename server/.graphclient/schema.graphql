schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type Query {
  accountDeployed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountDeployed
  accountDeployeds(
    skip: Int = 0
    first: Int = 100
    orderBy: AccountDeployed_orderBy
    orderDirection: OrderDirection
    where: AccountDeployed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AccountDeployed!]!
  deposited(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposited
  depositeds(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposited_orderBy
    orderDirection: OrderDirection
    where: Deposited_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Deposited!]!
  signatureAggregatorChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SignatureAggregatorChanged
  signatureAggregatorChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: SignatureAggregatorChanged_orderBy
    orderDirection: OrderDirection
    where: SignatureAggregatorChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SignatureAggregatorChanged!]!
  stakeLocked(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeLocked
  stakeLockeds(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeLocked_orderBy
    orderDirection: OrderDirection
    where: StakeLocked_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeLocked!]!
  stakeUnlocked(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeUnlocked
  stakeUnlockeds(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeUnlocked_orderBy
    orderDirection: OrderDirection
    where: StakeUnlocked_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeUnlocked!]!
  stakeWithdrawn(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeWithdrawn
  stakeWithdrawns(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeWithdrawn_orderBy
    orderDirection: OrderDirection
    where: StakeWithdrawn_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeWithdrawn!]!
  userOp(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserOp
  userOps(
    skip: Int = 0
    first: Int = 100
    orderBy: UserOp_orderBy
    orderDirection: OrderDirection
    where: UserOp_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserOp!]!
  withdrawn(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdrawn
  withdrawns(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdrawn_orderBy
    orderDirection: OrderDirection
    where: Withdrawn_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Withdrawn!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  crossUserOps(orderBy: UserOp_orderBy, orderDirection: OrderDirection, where: UserOp_filter, skip: Int = 0, first: Int = 100, indexerNames: [String!]!): [UserOp!]!
}

type Subscription {
  accountDeployed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountDeployed
  accountDeployeds(
    skip: Int = 0
    first: Int = 100
    orderBy: AccountDeployed_orderBy
    orderDirection: OrderDirection
    where: AccountDeployed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AccountDeployed!]!
  deposited(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Deposited
  depositeds(
    skip: Int = 0
    first: Int = 100
    orderBy: Deposited_orderBy
    orderDirection: OrderDirection
    where: Deposited_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Deposited!]!
  signatureAggregatorChanged(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SignatureAggregatorChanged
  signatureAggregatorChangeds(
    skip: Int = 0
    first: Int = 100
    orderBy: SignatureAggregatorChanged_orderBy
    orderDirection: OrderDirection
    where: SignatureAggregatorChanged_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SignatureAggregatorChanged!]!
  stakeLocked(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeLocked
  stakeLockeds(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeLocked_orderBy
    orderDirection: OrderDirection
    where: StakeLocked_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeLocked!]!
  stakeUnlocked(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeUnlocked
  stakeUnlockeds(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeUnlocked_orderBy
    orderDirection: OrderDirection
    where: StakeUnlocked_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeUnlocked!]!
  stakeWithdrawn(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeWithdrawn
  stakeWithdrawns(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeWithdrawn_orderBy
    orderDirection: OrderDirection
    where: StakeWithdrawn_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeWithdrawn!]!
  userOp(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserOp
  userOps(
    skip: Int = 0
    first: Int = 100
    orderBy: UserOp_orderBy
    orderDirection: OrderDirection
    where: UserOp_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserOp!]!
  withdrawn(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Withdrawn
  withdrawns(
    skip: Int = 0
    first: Int = 100
    orderBy: Withdrawn_orderBy
    orderDirection: OrderDirection
    where: Withdrawn_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Withdrawn!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type AccountDeployed {
  id: Bytes!
  userOpHash: Bytes!
  sender: Bytes!
  factory: Bytes!
  paymaster: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input AccountDeployed_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  userOpHash: Bytes
  userOpHash_not: Bytes
  userOpHash_gt: Bytes
  userOpHash_lt: Bytes
  userOpHash_gte: Bytes
  userOpHash_lte: Bytes
  userOpHash_in: [Bytes!]
  userOpHash_not_in: [Bytes!]
  userOpHash_contains: Bytes
  userOpHash_not_contains: Bytes
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  factory: Bytes
  factory_not: Bytes
  factory_gt: Bytes
  factory_lt: Bytes
  factory_gte: Bytes
  factory_lte: Bytes
  factory_in: [Bytes!]
  factory_not_in: [Bytes!]
  factory_contains: Bytes
  factory_not_contains: Bytes
  paymaster: Bytes
  paymaster_not: Bytes
  paymaster_gt: Bytes
  paymaster_lt: Bytes
  paymaster_gte: Bytes
  paymaster_lte: Bytes
  paymaster_in: [Bytes!]
  paymaster_not_in: [Bytes!]
  paymaster_contains: Bytes
  paymaster_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AccountDeployed_filter]
  or: [AccountDeployed_filter]
}

enum AccountDeployed_orderBy {
  id
  userOpHash
  sender
  factory
  paymaster
  blockNumber
  blockTimestamp
  transactionHash
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type Deposited {
  id: Bytes!
  account: Bytes!
  totalDeposit: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input Deposited_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  totalDeposit: BigInt
  totalDeposit_not: BigInt
  totalDeposit_gt: BigInt
  totalDeposit_lt: BigInt
  totalDeposit_gte: BigInt
  totalDeposit_lte: BigInt
  totalDeposit_in: [BigInt!]
  totalDeposit_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Deposited_filter]
  or: [Deposited_filter]
}

enum Deposited_orderBy {
  id
  account
  totalDeposit
  blockNumber
  blockTimestamp
  transactionHash
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type SignatureAggregatorChanged {
  id: Bytes!
  aggregator: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input SignatureAggregatorChanged_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  aggregator: Bytes
  aggregator_not: Bytes
  aggregator_gt: Bytes
  aggregator_lt: Bytes
  aggregator_gte: Bytes
  aggregator_lte: Bytes
  aggregator_in: [Bytes!]
  aggregator_not_in: [Bytes!]
  aggregator_contains: Bytes
  aggregator_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SignatureAggregatorChanged_filter]
  or: [SignatureAggregatorChanged_filter]
}

enum SignatureAggregatorChanged_orderBy {
  id
  aggregator
  blockNumber
  blockTimestamp
  transactionHash
}

type StakeLocked {
  id: Bytes!
  account: Bytes!
  totalStaked: BigInt!
  unstakeDelaySec: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input StakeLocked_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  totalStaked: BigInt
  totalStaked_not: BigInt
  totalStaked_gt: BigInt
  totalStaked_lt: BigInt
  totalStaked_gte: BigInt
  totalStaked_lte: BigInt
  totalStaked_in: [BigInt!]
  totalStaked_not_in: [BigInt!]
  unstakeDelaySec: BigInt
  unstakeDelaySec_not: BigInt
  unstakeDelaySec_gt: BigInt
  unstakeDelaySec_lt: BigInt
  unstakeDelaySec_gte: BigInt
  unstakeDelaySec_lte: BigInt
  unstakeDelaySec_in: [BigInt!]
  unstakeDelaySec_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StakeLocked_filter]
  or: [StakeLocked_filter]
}

enum StakeLocked_orderBy {
  id
  account
  totalStaked
  unstakeDelaySec
  blockNumber
  blockTimestamp
  transactionHash
}

type StakeUnlocked {
  id: Bytes!
  account: Bytes!
  withdrawTime: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input StakeUnlocked_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  withdrawTime: BigInt
  withdrawTime_not: BigInt
  withdrawTime_gt: BigInt
  withdrawTime_lt: BigInt
  withdrawTime_gte: BigInt
  withdrawTime_lte: BigInt
  withdrawTime_in: [BigInt!]
  withdrawTime_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StakeUnlocked_filter]
  or: [StakeUnlocked_filter]
}

enum StakeUnlocked_orderBy {
  id
  account
  withdrawTime
  blockNumber
  blockTimestamp
  transactionHash
}

type StakeWithdrawn {
  id: Bytes!
  account: Bytes!
  withdrawAddress: Bytes!
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input StakeWithdrawn_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  withdrawAddress: Bytes
  withdrawAddress_not: Bytes
  withdrawAddress_gt: Bytes
  withdrawAddress_lt: Bytes
  withdrawAddress_gte: Bytes
  withdrawAddress_lte: Bytes
  withdrawAddress_in: [Bytes!]
  withdrawAddress_not_in: [Bytes!]
  withdrawAddress_contains: Bytes
  withdrawAddress_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StakeWithdrawn_filter]
  or: [StakeWithdrawn_filter]
}

enum StakeWithdrawn_orderBy {
  id
  account
  withdrawAddress
  amount
  blockNumber
  blockTimestamp
  transactionHash
}

type UserOp {
  id: ID!
  transactionHash: Bytes
  userOpHash: Bytes
  sender: Bytes
  paymaster: Bytes
  nonce: BigInt
  actualGasCost: BigInt
  actualGasPrice: BigInt
  actualGasUsed: BigInt
  success: Boolean
  revertReason: Bytes
  blockTime: BigInt
  blockNumber: BigInt
  network: String
  input: Bytes
  target: Bytes
  callData: Bytes
  beneficiary: Bytes
  factory: Bytes
  indexerName: String
}

input UserOp_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  userOpHash: Bytes
  userOpHash_not: Bytes
  userOpHash_gt: Bytes
  userOpHash_lt: Bytes
  userOpHash_gte: Bytes
  userOpHash_lte: Bytes
  userOpHash_in: [Bytes!]
  userOpHash_not_in: [Bytes!]
  userOpHash_contains: Bytes
  userOpHash_not_contains: Bytes
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  paymaster: Bytes
  paymaster_not: Bytes
  paymaster_gt: Bytes
  paymaster_lt: Bytes
  paymaster_gte: Bytes
  paymaster_lte: Bytes
  paymaster_in: [Bytes!]
  paymaster_not_in: [Bytes!]
  paymaster_contains: Bytes
  paymaster_not_contains: Bytes
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  actualGasCost: BigInt
  actualGasCost_not: BigInt
  actualGasCost_gt: BigInt
  actualGasCost_lt: BigInt
  actualGasCost_gte: BigInt
  actualGasCost_lte: BigInt
  actualGasCost_in: [BigInt!]
  actualGasCost_not_in: [BigInt!]
  actualGasPrice: BigInt
  actualGasPrice_not: BigInt
  actualGasPrice_gt: BigInt
  actualGasPrice_lt: BigInt
  actualGasPrice_gte: BigInt
  actualGasPrice_lte: BigInt
  actualGasPrice_in: [BigInt!]
  actualGasPrice_not_in: [BigInt!]
  actualGasUsed: BigInt
  actualGasUsed_not: BigInt
  actualGasUsed_gt: BigInt
  actualGasUsed_lt: BigInt
  actualGasUsed_gte: BigInt
  actualGasUsed_lte: BigInt
  actualGasUsed_in: [BigInt!]
  actualGasUsed_not_in: [BigInt!]
  success: Boolean
  success_not: Boolean
  success_in: [Boolean!]
  success_not_in: [Boolean!]
  revertReason: Bytes
  revertReason_not: Bytes
  revertReason_gt: Bytes
  revertReason_lt: Bytes
  revertReason_gte: Bytes
  revertReason_lte: Bytes
  revertReason_in: [Bytes!]
  revertReason_not_in: [Bytes!]
  revertReason_contains: Bytes
  revertReason_not_contains: Bytes
  blockTime: BigInt
  blockTime_not: BigInt
  blockTime_gt: BigInt
  blockTime_lt: BigInt
  blockTime_gte: BigInt
  blockTime_lte: BigInt
  blockTime_in: [BigInt!]
  blockTime_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  network: String
  network_not: String
  network_gt: String
  network_lt: String
  network_gte: String
  network_lte: String
  network_in: [String!]
  network_not_in: [String!]
  network_contains: String
  network_contains_nocase: String
  network_not_contains: String
  network_not_contains_nocase: String
  network_starts_with: String
  network_starts_with_nocase: String
  network_not_starts_with: String
  network_not_starts_with_nocase: String
  network_ends_with: String
  network_ends_with_nocase: String
  network_not_ends_with: String
  network_not_ends_with_nocase: String
  input: Bytes
  input_not: Bytes
  input_gt: Bytes
  input_lt: Bytes
  input_gte: Bytes
  input_lte: Bytes
  input_in: [Bytes!]
  input_not_in: [Bytes!]
  input_contains: Bytes
  input_not_contains: Bytes
  target: Bytes
  target_not: Bytes
  target_gt: Bytes
  target_lt: Bytes
  target_gte: Bytes
  target_lte: Bytes
  target_in: [Bytes!]
  target_not_in: [Bytes!]
  target_contains: Bytes
  target_not_contains: Bytes
  callData: Bytes
  callData_not: Bytes
  callData_gt: Bytes
  callData_lt: Bytes
  callData_gte: Bytes
  callData_lte: Bytes
  callData_in: [Bytes!]
  callData_not_in: [Bytes!]
  callData_contains: Bytes
  callData_not_contains: Bytes
  beneficiary: Bytes
  beneficiary_not: Bytes
  beneficiary_gt: Bytes
  beneficiary_lt: Bytes
  beneficiary_gte: Bytes
  beneficiary_lte: Bytes
  beneficiary_in: [Bytes!]
  beneficiary_not_in: [Bytes!]
  beneficiary_contains: Bytes
  beneficiary_not_contains: Bytes
  factory: Bytes
  factory_not: Bytes
  factory_gt: Bytes
  factory_lt: Bytes
  factory_gte: Bytes
  factory_lte: Bytes
  factory_in: [Bytes!]
  factory_not_in: [Bytes!]
  factory_contains: Bytes
  factory_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [UserOp_filter]
  or: [UserOp_filter]
}

enum UserOp_orderBy {
  id
  transactionHash
  userOpHash
  sender
  paymaster
  nonce
  actualGasCost
  actualGasPrice
  actualGasUsed
  success
  revertReason
  blockTime
  blockNumber
  network
  input
  target
  callData
  beneficiary
  factory
}

type Withdrawn {
  id: Bytes!
  account: Bytes!
  withdrawAddress: Bytes!
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input Withdrawn_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  withdrawAddress: Bytes
  withdrawAddress_not: Bytes
  withdrawAddress_gt: Bytes
  withdrawAddress_lt: Bytes
  withdrawAddress_gte: Bytes
  withdrawAddress_lte: Bytes
  withdrawAddress_in: [Bytes!]
  withdrawAddress_not_in: [Bytes!]
  withdrawAddress_contains: Bytes
  withdrawAddress_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Withdrawn_filter]
  or: [Withdrawn_filter]
}

enum Withdrawn_orderBy {
  id
  account
  withdrawAddress
  amount
  blockNumber
  blockTimestamp
  transactionHash
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}